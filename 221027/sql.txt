USE testing1;
 testing1 DB를 사용한다, 접속한다

CREATE SCHEMA `testing1` DEFAULT CHARACTER SET utf8mb4 ;

CREATE TABLE `testing1`. `new_table1` (
    `idx` INT NOT NULL,
    `new_table1` VARCHAR(45) NULL,
    PRIMARY KEY (`idx`));

CREATE : 생성하는 명령어
 - DB, TABLE

DEFAULT CHARACTER SET utf8mb4
 - utf8mb4 방식으로 인코딩한다 < 저장할 때의 방식
 - txt 파일 만들 때 선택하는 인코딩과 같다

`testing1`.`new_table1`
 - `DB명`.`생성할 테이블명`

 (  `idx` INT NOT NULL,
    `new_table1` VARCHAR(45) NULL,
    PRIMARY KEY (`idx`));
 - (`컬럼명` 자료형 옵션, `컬럼명` 자료형 옵션,  옵션)
 - idx 컬럼명을 INT 자료형을 사용하여 생성하되 빈값이면 안된다
 - new_table1 컬럼명을 VARCHAR(45) 자료형을 사용하여 생성하고 빈값이여도 상관없다
 - PRIMARY KEY(고유 식별 컬럼, 값?)으로 idx를 설정한다

자료형(간단)
 - BOOLEAN : 참/거짓, 1BYTE

자료형(숫자)
 - TINYINT : 1 BTYE의 정수 < -128 ~ 127, 0 ~ 255 // 0 ~ 2^8
    - 잡설 : 127 + 1 => -128 < 비폭력주의 간디의 탄생 => 0 - 1 = -1 > 255
 - INT : 4 BTYES의 정수 < -2,147,483,648 ~ 2,147,483,648
 - BIGINT : 8 BBTYES의 정수
 - FLOAT : 4 BTYES의 실수
    - 계산할 때 확률적으로 오류가 뜬다
 - DOUBLE : 8 BTYES의 실수
    - FLOAT는 조금 덜 오류가 뜬다
 - BIT(n) : n BIT의 정수 < 몇개든지 내가 설정한다
    - BIT(4) => 0 ~ 15

자료형(문자)
 - CHAR(n) : n BYTE의 문자, 최대 2^8 BYTES까지만 가능
 - VARCHAR(n) : 최대 n BYTE의 가변 문자, 최대 2^8 BYTES까지만 가능
    - ASCII => 1 BYTE (8BIT) < 최대 몇글자 ? 2^8 < 0 ~ 126 < 2^7 - 1 < 7BIT 앞에 1BIT를 버리고 총 8BIT를 사용한다
    - UTF-8 => 1 ~ 3 BYTES < 최대로 넣을 수 있는 글자수의 범위 < (2^8 / 3) ~ 2^8  // ex) 영어라면 1글자에 1BYTE, 한글이면 1글자에 3BYTES를 먹는다라고 생각해서 영어면 2^8, 한글이면 2^8 /3 
    - UTF-8mb4 => 1 ~ 4 BYTES
    - UTF-16 => 3 BYTES까지만
 - TEXT : 최대 2^16 BYTES의 가변 문자
 - LONGTEXT : 최대 2^32 BYTES의 가변 문자

자료형(시간)
 - DATA : 3 BYTE의 날짜 => YYYY-MM-DD
 - DATATIME : 8 BYTE의 날짜와 시간 YYYY-MM-DD HH:MM:SS
 - TIMESTAMP : 4 BYTE의 UTC 시간의 날짜와 시간 YYYY-MM-DD HH:MM:SS 
 - YEAR : 1 BYTE의 연도 YYYY

옵션
 - NOT NULL : 빈값이면 안된다
 - UNIQUE : 값이 중복되면 안된다
 - PRIMARY KEY : 고유 식별 키
 - FOREIGN KEY : 테이블 연결 시 사용
 - CHECK : 저장할 데이터의 범위나 조건을 지정한다
 - DEFAULT : 기본값
 - AUTO_INCREMENT : index 값 자동 증가 
 - COMMENT : 설명


SELECT * FROM new_table1;
SELECT : 데이터를 가져온다
* : 전부
FROM : 어디서 가져올지 

SELECT * FROM new_table1 WHERE name="***";
SELECT * FROM new_table1 WHERE 조건;

SELECT * FROM new_table1 WHERE name LIKE '어쩌구';
 - name에 '어쩌구'가 포함되어있으면

SELECT name FROM new_table1 WHERE name LIKE '어쩌구';
  - name에 '어쩌구'가 포함되어있으면 name을 가져온다

SELECT * FROM new_table1 ORDER BY name DESC;
 - name을 기준으로 내림차순으로 가져온다 (ASC : 오름차순)
SELECT * FROM new_table1 ORDER BY name ASC;

SELECT COUNT FROM new_table1;
 - 개수 가져오기

INSERT INTO
 - 데이터를 저장한다.
 - INTO : 어디에
 - ('어쩌구') : 컬럼명
 - VALUES ('0') : 어떤 값들인가
 - `` << 객체(컬럼명)
 - '' << 고유값(스트링이나 숫자 등등 데이터)

INSERT INTO `new_table1` SET `idx`=`0`, `name`=`sadasdasd`, `id`=`sdasdas`, `create_at`=`2022-10-27`;

INSERT INTO `new_table1` (`idx`, `name`, `password`, `id`, `create_at`) VALUES ('0', '정현', '1234', 'jjhjjh', '2022-10-27');
INSERT INTO `new_table1` (`idx`, `name`, `password`, `id`, `create_at`) VALUES ('1', '정현', '1234', 'jjhjjh', '2022-10-27');

